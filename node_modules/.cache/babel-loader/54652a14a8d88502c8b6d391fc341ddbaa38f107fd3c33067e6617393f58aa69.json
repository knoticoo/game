{"ast":null,"code":"import { createSlice } from '@reduxjs/toolkit';\nconst initialState = {\n  currentBattle: null,\n  battleState: 'idle',\n  // 'idle', 'preparing', 'active', 'victory', 'defeat'\n  playerUnits: [],\n  enemyUnits: [],\n  battleLog: [],\n  turnOrder: [],\n  currentTurn: 0,\n  battleRewards: {\n    experience: 0,\n    gold: 0,\n    items: []\n  },\n  battleStatistics: {\n    battlesWon: 0,\n    battlesLost: 0,\n    totalDamageDealt: 0,\n    totalDamageTaken: 0,\n    unitsLost: 0\n  },\n  autoBattle: false,\n  battleSpeed: 'normal'\n};\nconst combatSlice = createSlice({\n  name: 'combat',\n  initialState,\n  reducers: {\n    startBattle: (state, action) => {\n      const {\n        playerUnits,\n        enemyUnits,\n        battleType\n      } = action.payload;\n      state.currentBattle = {\n        id: Date.now(),\n        type: battleType,\n        startTime: Date.now()\n      };\n      state.playerUnits = playerUnits.map(unit => ({\n        ...unit,\n        currentHealth: unit.maxHealth,\n        statusEffects: [],\n        isAlive: true\n      }));\n      state.enemyUnits = enemyUnits.map(unit => ({\n        ...unit,\n        currentHealth: unit.maxHealth,\n        statusEffects: [],\n        isAlive: true\n      }));\n      state.battleState = 'preparing';\n      state.battleLog = [];\n      state.turnOrder = [...playerUnits, ...enemyUnits].sort((a, b) => b.speed - a.speed);\n      state.currentTurn = 0;\n    },\n    endBattle: (state, action) => {\n      const {\n        result,\n        rewards\n      } = action.payload;\n      state.battleState = result; // 'victory' or 'defeat'\n      state.battleRewards = rewards || {\n        experience: 0,\n        gold: 0,\n        items: []\n      };\n      if (result === 'victory') {\n        state.battleStatistics.battlesWon += 1;\n      } else {\n        state.battleStatistics.battlesLost += 1;\n      }\n\n      // Clear battle data after a delay\n      setTimeout(() => {\n        state.currentBattle = null;\n        state.battleState = 'idle';\n        state.playerUnits = [];\n        state.enemyUnits = [];\n        state.battleLog = [];\n      }, 3000);\n    },\n    performAction: (state, action) => {\n      const {\n        unitId,\n        actionType,\n        targetId,\n        damage,\n        effects\n      } = action.payload;\n      const unit = [...state.playerUnits, ...state.enemyUnits].find(u => u.id === unitId);\n      const target = [...state.playerUnits, ...state.enemyUnits].find(u => u.id === targetId);\n      if (unit && target) {\n        // Apply damage\n        if (damage > 0) {\n          target.currentHealth = Math.max(0, target.currentHealth - damage);\n          if (target.currentHealth === 0) {\n            target.isAlive = false;\n          }\n        }\n\n        // Apply status effects\n        if (effects) {\n          target.statusEffects.push(...effects);\n        }\n\n        // Add to battle log\n        state.battleLog.push({\n          unitId,\n          targetId,\n          actionType,\n          damage,\n          effects,\n          timestamp: Date.now()\n        });\n\n        // Update statistics\n        if (state.playerUnits.some(u => u.id === unitId)) {\n          state.battleStatistics.totalDamageDealt += damage;\n        } else {\n          state.battleStatistics.totalDamageTaken += damage;\n        }\n      }\n    },\n    nextTurn: state => {\n      state.currentTurn = (state.currentTurn + 1) % state.turnOrder.length;\n    },\n    addBattleLog: (state, action) => {\n      state.battleLog.push({\n        ...action.payload,\n        timestamp: Date.now()\n      });\n    },\n    toggleAutoBattle: state => {\n      state.autoBattle = !state.autoBattle;\n    },\n    setBattleSpeed: (state, action) => {\n      state.battleSpeed = action.payload;\n    },\n    updateBattleStatistics: (state, action) => {\n      state.battleStatistics = {\n        ...state.battleStatistics,\n        ...action.payload\n      };\n    },\n    resetCombat: state => {\n      return initialState;\n    }\n  }\n});\nexport const {\n  startBattle,\n  endBattle,\n  performAction,\n  nextTurn,\n  addBattleLog,\n  toggleAutoBattle,\n  setBattleSpeed,\n  updateBattleStatistics,\n  resetCombat\n} = combatSlice.actions;\nexport default combatSlice.reducer;","map":{"version":3,"names":["createSlice","initialState","currentBattle","battleState","playerUnits","enemyUnits","battleLog","turnOrder","currentTurn","battleRewards","experience","gold","items","battleStatistics","battlesWon","battlesLost","totalDamageDealt","totalDamageTaken","unitsLost","autoBattle","battleSpeed","combatSlice","name","reducers","startBattle","state","action","battleType","payload","id","Date","now","type","startTime","map","unit","currentHealth","maxHealth","statusEffects","isAlive","sort","a","b","speed","endBattle","result","rewards","setTimeout","performAction","unitId","actionType","targetId","damage","effects","find","u","target","Math","max","push","timestamp","some","nextTurn","length","addBattleLog","toggleAutoBattle","setBattleSpeed","updateBattleStatistics","resetCombat","actions","reducer"],"sources":["/workspace/src/store/slices/combatSlice.js"],"sourcesContent":["import { createSlice } from '@reduxjs/toolkit';\n\nconst initialState = {\n  currentBattle: null,\n  battleState: 'idle', // 'idle', 'preparing', 'active', 'victory', 'defeat'\n  playerUnits: [],\n  enemyUnits: [],\n  battleLog: [],\n  turnOrder: [],\n  currentTurn: 0,\n  battleRewards: {\n    experience: 0,\n    gold: 0,\n    items: [],\n  },\n  battleStatistics: {\n    battlesWon: 0,\n    battlesLost: 0,\n    totalDamageDealt: 0,\n    totalDamageTaken: 0,\n    unitsLost: 0,\n  },\n  autoBattle: false,\n  battleSpeed: 'normal',\n};\n\nconst combatSlice = createSlice({\n  name: 'combat',\n  initialState,\n  reducers: {\n    startBattle: (state, action) => {\n      const { playerUnits, enemyUnits, battleType } = action.payload;\n      state.currentBattle = {\n        id: Date.now(),\n        type: battleType,\n        startTime: Date.now(),\n      };\n      state.playerUnits = playerUnits.map(unit => ({\n        ...unit,\n        currentHealth: unit.maxHealth,\n        statusEffects: [],\n        isAlive: true,\n      }));\n      state.enemyUnits = enemyUnits.map(unit => ({\n        ...unit,\n        currentHealth: unit.maxHealth,\n        statusEffects: [],\n        isAlive: true,\n      }));\n      state.battleState = 'preparing';\n      state.battleLog = [];\n      state.turnOrder = [...playerUnits, ...enemyUnits].sort((a, b) => b.speed - a.speed);\n      state.currentTurn = 0;\n    },\n    endBattle: (state, action) => {\n      const { result, rewards } = action.payload;\n      state.battleState = result; // 'victory' or 'defeat'\n      state.battleRewards = rewards || { experience: 0, gold: 0, items: [] };\n      \n      if (result === 'victory') {\n        state.battleStatistics.battlesWon += 1;\n      } else {\n        state.battleStatistics.battlesLost += 1;\n      }\n      \n      // Clear battle data after a delay\n      setTimeout(() => {\n        state.currentBattle = null;\n        state.battleState = 'idle';\n        state.playerUnits = [];\n        state.enemyUnits = [];\n        state.battleLog = [];\n      }, 3000);\n    },\n    performAction: (state, action) => {\n      const { unitId, actionType, targetId, damage, effects } = action.payload;\n      const unit = [...state.playerUnits, ...state.enemyUnits].find(u => u.id === unitId);\n      const target = [...state.playerUnits, ...state.enemyUnits].find(u => u.id === targetId);\n      \n      if (unit && target) {\n        // Apply damage\n        if (damage > 0) {\n          target.currentHealth = Math.max(0, target.currentHealth - damage);\n          if (target.currentHealth === 0) {\n            target.isAlive = false;\n          }\n        }\n        \n        // Apply status effects\n        if (effects) {\n          target.statusEffects.push(...effects);\n        }\n        \n        // Add to battle log\n        state.battleLog.push({\n          unitId,\n          targetId,\n          actionType,\n          damage,\n          effects,\n          timestamp: Date.now(),\n        });\n        \n        // Update statistics\n        if (state.playerUnits.some(u => u.id === unitId)) {\n          state.battleStatistics.totalDamageDealt += damage;\n        } else {\n          state.battleStatistics.totalDamageTaken += damage;\n        }\n      }\n    },\n    nextTurn: (state) => {\n      state.currentTurn = (state.currentTurn + 1) % state.turnOrder.length;\n    },\n    addBattleLog: (state, action) => {\n      state.battleLog.push({\n        ...action.payload,\n        timestamp: Date.now(),\n      });\n    },\n    toggleAutoBattle: (state) => {\n      state.autoBattle = !state.autoBattle;\n    },\n    setBattleSpeed: (state, action) => {\n      state.battleSpeed = action.payload;\n    },\n    updateBattleStatistics: (state, action) => {\n      state.battleStatistics = { ...state.battleStatistics, ...action.payload };\n    },\n    resetCombat: (state) => {\n      return initialState;\n    },\n  },\n});\n\nexport const {\n  startBattle,\n  endBattle,\n  performAction,\n  nextTurn,\n  addBattleLog,\n  toggleAutoBattle,\n  setBattleSpeed,\n  updateBattleStatistics,\n  resetCombat,\n} = combatSlice.actions;\n\nexport default combatSlice.reducer;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}